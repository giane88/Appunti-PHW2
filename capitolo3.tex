\section{Flusso di progetto nei sistemi eterogenei}\label{capitolo3}
Come abbiamo visto i sistemi embedded sono sistemi specializzati progettati per svolgere una o poche funzioni, molto spesso con vincoli stringenti. Questi tipi di sistemi sono progettati come \emph{SoC Multiprocessore} che sono diventati lo  standard di fatto di questo tipo di sistemi. Molti dei sistemi embedded hanno dei vincoli stringenti per quanto riguarda le prestazioni, l'ottimizzazione delle applicazioni per sistemi embedded complessi è un problema difficile, che richiede progettisti con un alto livello di esperienza per identificare la soluzione migliore.\\
Solitamente si utilizzano delle piattaforme hardware di base, tuttavia i vincoli stringenti richiedono processori dedicati per accelerare specifiche funzioni.\\
Per definire il problema dobbiamo considerare numerosi aspetti:
\begin{description}
\item[Job:] ovvero l'attività da eseguire e completare affinché il sistema soddisfi le specifiche.
\item[Punto di implementazione:] indica il modo nel quale svolgere un lavoro. Rappresenta una combinazione di \emph{latenza} e \emph{risorse necessarie}.
\item[Mapping:] assegna ogni \emph{job} ad un possibile \emph{punto di implementazione}, in modo da rispettare i vincoli imposti dalle risorse.
\item[Scheduling:] determina l'ordine di esecuzione di tutti i lavori.
\item[Obiettivo:] minimizzare il tempo di esecuzione complessivo dell'applicazione sull'architettura designata
\end{description}
Per quanto riguarda l'\emph{obiettivo} di minimizzare il tempo di esecuzione possiamo intervenire in diversi modi, come quello di analizzare, valutare ed ottimizzare differenti alternative, ed una volta individuata una soluzione valutarne la qualità prima della sua implementazione.\\
La progettazione di sistemi eterogenei a multi processore richiede diversi fasi:
\begin{itemize}
\item Una fase di partizionamento dell'applicazione (\emph{partitionig})
\item Una fase di assegnamento dei task ai diversi elementi architetturali (\emph{mapping})
\item La determinazione dell'ordine di esecuzione dei task (\emph{scheduling})
\end{itemize}
La parte di \emph{scheduling} e di \emph{mapping} è un problema \emph{NP-completo} inoltre il problema di un design e l'interfacciamento di componenti eterogenei può generare delle soluzioni non ammissibili.\\
Una rappresentazione imparziale e unificata di software ed hardware supporta la fase di progettazione ed analisi, permette una facile valutazione delle soluzioni individuate e inoltre permette la migrazione dei task tra la parte hardware e quella software. Tecniche di progettazione iterative permettono di valutare soluzioni differenti, aiuta a determinare l'implementazione migliore ed infine il partizionamento dei moduli permette un maching più preciso rispetto ai criteri di progettazione. Esistono inoltre dei metodi di parallelizzazione che possono valutare il grado di parallelismo a livello di :
\begin{itemize}
\item Istruzione
\item Dati 
\item Task
\end{itemize}
Tuttavia si introducono problemi di dipendenza che devono essere soddisfatti.\\
il parallelismo dei dati è definito come il parallelismo ottenuto dall'esecuzione concorrente che utilizza porzioni di dati differenti.
Il parallelismo dei task invece viene definito come il parallelismo ottenuto dalla computazione su diverse strutture dati.
In molti casi si utilizza un misto delle due tecniche soprattutto in ambito scientifico.\\
Un \emph{grafico dei task} è un grafico $G=(T,E)$ nei quali i nodi rappresentano un gruppo di istruzioni e gli archi rappresentano le dipendenze, solitamente gli archi vengono indicati con il quantitativo di dati da trasferire in modo da considerare anche il ritardo di comunicazione.
Nel caso di grafi ciclici adotteremo la rappresentazione \emph{gerarchica dei grafi} nei quali i nodi son suddivisi in tre classi:
\begin{description}
\item[semplici:] un task senza altri sotto task,
\item[composto:] quando un task ha altri sotto task associati,
\item[loop:] task che rappresentano un ciclo in cui il corpo è un sotto-grafo
\end{description}